<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Air Writing - JavaScript</title>
    <!-- Load MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        
        /* Mirror the video and canvas for a selfie-view experience */
        #input_video { transform: scaleX(-1); position: absolute; width: 100%; height: 100%; object-fit: cover; }
        #output_canvas { transform: scaleX(-1); position: absolute; width: 100%; height: 100%; object-fit: cover; }
        
        #controls {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.7); color: white; padding: 15px; border-radius: 10px;
        }
        .status { font-weight: bold; color: #00ff00; }
    </style>
</head>
<body>

    <div id="container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>

        <div id="controls">
            <h2>AI Air Writing</h2>
            <p>‚òùÔ∏è <b>1 Finger:</b> Draw (Red)</p>
            <p>‚úåÔ∏è <b>2 Fingers:</b> Move (Selection Mode)</p>
            <p>üñêÔ∏è <b>Full Palm:</b> Eraser</p>
            <button onclick="clearCanvas()">Clear Screen</button>
            <p>Status: <span id="mode" class="status">Initializing...</span></p>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const modeStatus = document.getElementById('mode');

        let lastX = 0;
        let lastY = 0;
        let isDrawing = false;

        // Persistent drawing layer
        const drawCanvas = document.createElement('canvas');
        const drawCtx = drawCanvas.getContext('2d');

        function onResults(results) {
            // Match canvas size to video size
            if (drawCanvas.width !== canvasElement.width) {
                drawCanvas.width = canvasElement.width = videoElement.videoWidth;
                drawCanvas.height = canvasElement.height = videoElement.videoHeight;
            }

            // Clear the view canvas (the one that shows the video)
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Finger tip indices: Index (8), Middle (12), Ring (16), Pinky (20)
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];

                const x = indexTip.x * canvasElement.width;
                const y = indexTip.y * canvasElement.height;

                // Gesture Logic:
                const isIndexUp = indexTip.y < landmarks[6].y;
                const isMiddleUp = middleTip.y < landmarks[10].y;
                const isRingUp = ringTip.y < landmarks[14].y;
                const isPinkyUp = pinkyTip.y < landmarks[18].y;

                // 1. ERASER MODE (All fingers up)
                if (isIndexUp && isMiddleUp && isRingUp && isPinkyUp) {
                    modeStatus.innerText = "ERASER";
                    drawCtx.globalCompositeOperation = 'destination-out';
                    drawCtx.lineWidth = 50;
                    drawCircle(drawCtx, x, y, 25);
                    if (isDrawing) {
                        drawLine(drawCtx, lastX, lastY, x, y);
                    }
                    isDrawing = true;
                }
                // 2. SELECTION MODE (Index and Middle up) - Just hover
                else if (isIndexUp && isMiddleUp) {
                    modeStatus.innerText = "HOVER / SELECT";
                    isDrawing = false; // Stop drawing
                    // Draw a pointer circle
                    canvasCtx.fillStyle = "white";
                    canvasCtx.beginPath();
                    canvasCtx.arc(x, y, 10, 0, 2 * Math.PI);
                    canvasCtx.fill();
                } 
                // 3. DRAWING MODE (Only Index up)
                else if (isIndexUp) {
                    modeStatus.innerText = "DRAWING";
                    drawCtx.globalCompositeOperation = 'source-over';
                    drawCtx.strokeStyle = "red";
                    drawCtx.lineWidth = 5;
                    drawCtx.lineCap = "round";

                    if (isDrawing) {
                        drawLine(drawCtx, lastX, lastY, x, y);
                    }
                    isDrawing = true;
                } else {
                    isDrawing = false;
                }

                lastX = x;
                lastY = y;

                // Draw hand skeleton (Optional)
                // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            }

            // Overlay the persistent drawing onto the main canvas
            canvasCtx.drawImage(drawCanvas, 0, 0);
            canvasCtx.restore();
        }

        function drawLine(ctx, x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawCircle(ctx, x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.fill();
        }

        function clearCanvas() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        }

        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Setup Camera
        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoElement.srcObject = stream;
            videoElement.play();
            
            async function detectionLoop() {
                await hands.send({image: videoElement});
                requestAnimationFrame(detectionLoop);
            }
            detectionLoop();
        }

        startCamera();
    </script>
</body>
</html>
