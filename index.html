<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Air Writer - Gesture Controlled</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; background: #000; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        video, canvas {
            position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }

        #ui-overlay {
            position: absolute; top: 100px; left: 20px; z-index: 10;
            color: white; pointer-events: none;
        }
        .info-box { background: rgba(0,0,0,0.7); padding: 5px 15px; margin-bottom: 8px; border-left: 5px solid #00ffcc; }
        .fps { font-size: 28px; font-weight: bold; color: #ff0055; }

        /* Visual indicator for the current color */
        #active-indicator {
            position: absolute; top: 20px; right: 20px; width: 60px; height: 60px;
            border-radius: 50%; border: 4px solid white; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="container">
        <video id="input_video" playsinline></video>
        <canvas id="drawing_canvas"></canvas> 
        <canvas id="ui_canvas"></canvas>      

        <div id="ui-overlay">
            <div class="info-box fps">FPS: <span id="fps">0</span></div>
            <div class="info-box">GESTURE: <span id="gesture" style="color:#00ffcc">---</span></div>
            <div class="info-box">MODE: <span id="mode" style="color:#ffff00">---</span></div>
        </div>

        <div id="active-indicator" style="background: red;"></div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const drawingCanvas = document.getElementById('drawing_canvas');
        const uiCanvas = document.getElementById('ui_canvas');
        const drawCtx = drawingCanvas.getContext('2d');
        const uiCtx = uiCanvas.getContext('2d');
        const indicator = document.getElementById('active-indicator');

        let currentColor = 'red';
        let lastX = 0, lastY = 0;
        let isWriting = false;
        let lastTime = 0;

        // Define Virtual Buttons (Relative to canvas width/height)
        const buttons = [
            { name: 'RED', color: 'red', x: 50, y: 20, w: 120, h: 60 },
            { name: 'GREEN', color: '#00ff00', x: 190, y: 20, w: 120, h: 60 },
            { name: 'BLUE', color: '#0088ff', x: 330, y: 20, w: 120, h: 60 },
            { name: 'YELLOW', color: 'yellow', x: 470, y: 20, w: 120, h: 60 },
            { name: 'CLEAR', color: 'white', x: 610, y: 20, w: 120, h: 60 }
        ];

        function drawUIButtons() {
            buttons.forEach(btn => {
                // Draw Box
                uiCtx.fillStyle = (btn.name === 'CLEAR') ? '#ff4444' : btn.color;
                uiCtx.globalAlpha = 0.8;
                uiCtx.fillRect(btn.x, btn.y, btn.w, btn.h);
                
                // Draw Text
                uiCtx.globalAlpha = 1.0;
                uiCtx.fillStyle = 'black';
                uiCtx.font = 'bold 20px Arial';
                uiCtx.textAlign = 'center';
                uiCtx.fillText(btn.name, btn.x + btn.w/2, btn.y + 38);
            });
        }

        function onResults(results) {
            if (drawingCanvas.width !== videoElement.videoWidth) {
                drawingCanvas.width = uiCanvas.width = videoElement.videoWidth;
                drawingCanvas.height = uiCanvas.height = videoElement.videoHeight;
            }

            const now = performance.now();
            document.getElementById('fps').innerText = Math.round(1000 / (now - lastTime));
            lastTime = now;

            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            drawUIButtons(); // Draw the virtual buttons on every frame

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Draw Hand Skeleton
                drawConnectors(uiCtx, landmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 3});
                drawLandmarks(uiCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 4});

                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];

                // Note: Landmarks are mirrored, but our canvas is also mirrored. 
                // So indexTip.x * width works correctly.
                const x = indexTip.x * drawingCanvas.width;
                const y = indexTip.y * drawingCanvas.height;

                const isIndexUp = indexTip.y < landmarks[6].y;
                const isMiddleUp = middleTip.y < landmarks[10].y;
                const isRingUp = ringTip.y < landmarks[14].y;
                const isPinkyUp = pinkyTip.y < landmarks[18].y;

                // --- GESTURE LOGIC ---

                // 1. ERASER (Open Hand)
                if (isIndexUp && isMiddleUp && isRingUp && isPinkyUp) {
                    document.getElementById('gesture').innerText = "Open Palm";
                    document.getElementById('mode').innerText = "ERASER";
                    drawCtx.globalCompositeOperation = 'destination-out';
                    if (isWriting) {
                        drawLine(drawCtx, lastX, lastY, x, y, 60);
                    }
                    isWriting = true;
                } 
                // 2. SELECTION / COLOR CHANGE (Two fingers)
                else if (isIndexUp && isMiddleUp) {
                    document.getElementById('gesture').innerText = "Selection";
                    document.getElementById('mode').innerText = "HOVERING";
                    isWriting = false;

                    // Draw a selector circle
                    uiCtx.beginPath();
                    uiCtx.strokeStyle = "white";
                    uiCtx.lineWidth = 4;
                    uiCtx.arc(x, y, 20, 0, Math.PI * 2);
                    uiCtx.stroke();

                    // Check if selector is over a virtual button
                    buttons.forEach(btn => {
                        // Because video is mirrored, we check distance carefully
                        if (x > btn.x && x < btn.x + btn.w && y > btn.y && y < btn.y + btn.h) {
                            if (btn.name === 'CLEAR') {
                                drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                            } else {
                                currentColor = btn.color;
                                indicator.style.background = currentColor;
                            }
                            // Visual feedback on button hover
                            uiCtx.strokeStyle = "white";
                            uiCtx.lineWidth = 5;
                            uiCtx.strokeRect(btn.x, btn.y, btn.w, btn.h);
                        }
                    });
                }
                // 3. WRITING (One finger)
                else if (isIndexUp) {
                    document.getElementById('gesture').innerText = "Index Up";
                    document.getElementById('mode').innerText = "WRITING";
                    drawCtx.globalCompositeOperation = 'source-over';
                    drawCtx.strokeStyle = currentColor;
                    if (isWriting) {
                        drawLine(drawCtx, lastX, lastY, x, y, 8);
                    }
                    isWriting = true;
                } else {
                    isWriting = false;
                }

                lastX = x; lastY = y;
            }
        }

        function drawLine(ctx, x1, y1, x2, y2, weight) {
            ctx.lineWidth = weight;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.8,
            minTrackingConfidence: 0.8
        });

        hands.onResults(onResults);

        async function init() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoElement.srcObject = stream;
            videoElement.play();
            async function loop() {
                await hands.send({image: videoElement});
                requestAnimationFrame(loop);
            }
            loop();
        }
        init();
    </script>
</body>
</html>
